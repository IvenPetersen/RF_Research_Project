%% sdr_live_callback.m
% Callback-basiertes Einlesen von I/Q vom Arduino DUE mit FIFO,
% vektorisierter DSP-Pipeline, Audioausgabe und GUI/FFT.
% Annahmen (aus Arduino-Code):
%  - Interleaved int16 I,Q,I,Q,...
%  - BLOCK_SIZE Samples pro Kanal pro Übertragung
%  - Bytes pro Block = BLOCK_SIZE * 4

clc; clear; close all force;

%% ---------------- Configuration ----------------
port = "COM9";
baud = 2000000;

BLOCK_SIZE = 512;       % gleich wie Arduino
SAMPLE_RATE = 40000;    % pro Kanal (I oder Q) [Hz]
plotWindow = 500;
fftLength = 4096;
fftLengthZP = 16384;
audioGain = 2;

% FIFO-Kapazität (Samples pro Kanal)
FIFO_BLOCKS = 256;  % Anzahl Blocks im FIFO (tweakbar). FIFO capacity = FIFO_BLOCKS * BLOCK_SIZE
FIFO_CAPACITY = FIFO_BLOCKS * BLOCK_SIZE;

% ADC Konstanten
Vref = 3.3;
LSB_V = Vref / 4096; % 12 Bit

% Hochpass 5 Hz (DC-Blocker)
fcHP = 5;                                   
aHP = exp(-2*pi*fcHP/SAMPLE_RATE);

% Tiefpass 15 kHz
fcLP = 15000;   
aLP = exp(-2*pi*fcLP/SAMPLE_RATE);
bLP = 1 - aLP;

%% ---------------- Serialport + Callback Setup ----------------
s = serialport(port, baud, "Timeout", 0.1);
flush(s);

% Bytes pro Übertragungsblock vom Arduino
bytesPerBlock = BLOCK_SIZE * 4;  % BLOCK_SIZE samples per channel -> BLOCK_SIZE*2 samples total -> *2 bytes each

% Initialisiere UserData als FIFO-Struct (shared zwischen Callback und Main)
ud = struct();
ud.fifoI = zeros(FIFO_CAPACITY, 1, 'int16');   % pre-alloc
ud.fifoQ = zeros(FIFO_CAPACITY, 1, 'int16');
ud.writePos = uint32(1);   
ud.readPos = uint32(1);
ud.count = uint32(0);      
ud.lock = false;           
ud.debugCounter = uint32(0);

s.UserData = ud;

% Callback wird ausgelöst, sobald vollständiger Block empfangen wurde
configureCallback(s, "byte", bytesPerBlock, @(src,evt) serialCallback(src, evt, BLOCK_SIZE));

%% ---------------- Audio Player ----------------
player = audioDeviceWriter('SampleRate', SAMPLE_RATE, ...
    'SupportVariableSizeInput', true, ...
    'BufferSize', BLOCK_SIZE*2);  % etwas Reserve

%% ---------------- Plot-Puffer Initialization ----------------
xI = zeros(plotWindow,1);
xQ = zeros(plotWindow,1);

fftI = zeros(fftLength,1);
fftQ = zeros(fftLength,1);

tPlot = (0:plotWindow-1)/SAMPLE_RATE;
f = (0:(fftLengthZP/2)) * (SAMPLE_RATE/fftLengthZP);

figure('Name','Live I/Q - Callback FIFO','NumberTitle','off');

subplot(2,2,1);
hI_time = plot(tPlot, xI);
xlabel('Zeit [s]'); ylabel('Volt I'); ylim([0 Vref]);
grid on; title('I – Zeitbereich');

subplot(2,2,2);
hI_fft = plot(f, zeros(length(f),1));
xlabel('Frequenz [Hz]'); ylabel('Amplitude'); grid on;
title('I – FFT');

subplot(2,2,3);
hQ_time = plot(tPlot, xQ);
xlabel('Zeit [s]'); ylabel('Volt Q'); ylim([0 Vref]);
grid on; title('Q – Zeitbereich');

subplot(2,2,4);
hQ_fft = plot(f, zeros(length(f),1));
xlabel('Frequenz [Hz]'); ylabel('Amplitude'); grid on;
title('Q – FFT');

drawnow;

%% ---------------- Initial filter states ----------------
% Separate initial conditions pro Kanal
zi_hpI = 0;    % HP I previous state
zi_hpQ = 0;    % HP Q previous state
zi_lpI = 0;    % LP I previous state
zi_lpQ = 0;    % LP Q previous state

%% ---------------- Main Loop ----------------
running = true;
plotUpdateCounter = 0;

try
    while running
        % Zugriff auf shared FIFO-Daten
        ud = s.UserData;  % Samples holen
        available = double(ud.count);  % Samples pro Kanal verfügbar

        if available >= BLOCK_SIZE
            % Lese I und Q aus FIFO
            [dataI, dataQ] = fifo_pop(s, BLOCK_SIZE);

            % Sicherstellen von BLOCK_SIZE
            if numel(dataI) < BLOCK_SIZE
                dataI(end+1:BLOCK_SIZE) = int16(0);
            end
            if numel(dataQ) < BLOCK_SIZE
                dataQ(end+1:BLOCK_SIZE) = int16(0);
            end

            % ---- Volt für Zeitplot (für GUI) ----
            voltI = double(dataI) * LSB_V;
            voltQ = double(dataQ) * LSB_V;

            %% ============ DSP (Vektorisierte Implementierung) ============
            % Skalierung für Audio mit Verstärkung
            xI_in = double(dataI) / 2048 * audioGain;   
            xQ_in = double(dataQ) / 2048 * audioGain;

            % Hochpass (DC-Blocker): filter([1 -1], [1 -aHP], x, zi)
            [yI_hp, zhpI] = filter([1 -1], [1 -aHP], xI_in, zi_hpI);
            [yQ_hp, zhpQ] = filter([1 -1], [1 -aHP], xQ_in, zi_hpQ);
            zi_hpI = zhpI(end);
            zi_hpQ = zhpQ(end);

            % Tiefpass (single pole): filter(bLP, [1 -aLP], y, zi)
            [yI_lp, zlpI] = filter(bLP, [1 -aLP], yI_hp, zi_lpI);
            [yQ_lp, zlpQ] = filter(bLP, [1 -aLP], yQ_hp, zi_lpQ);
            zi_lpI = zlpI(end);
            zi_lpQ = zlpQ(end);
            
            % Ausgabe der Audio
            dataAudio = [yI_lp, yQ_lp];
            step(player, dataAudio);

            %% ============ GUI Update (Rolling buffers) ============
            % Zeit-Plot: anhängen, dann zuschneiden → garantiert Länge plotWindow
            xI = [xI; voltI];
            if length(xI) > plotWindow
                xI = xI(end-plotWindow+1:end);
            end
            xQ = [xQ; voltQ];
            if length(xQ) > plotWindow
                xQ = xQ(end-plotWindow+1:end);
            end

            set(hI_time,'YData',xI);
            set(hQ_time,'YData',xQ);

            % FFT rolling buffer: anhängen, dann zuschneiden → garantiert Länge fftLength
            fftI = [fftI; voltI];
            if length(fftI) > fftLength
                fftI = fftI(end-fftLength+1:end);
            end
            fftQ = [fftQ; voltQ];
            if length(fftQ) > fftLength
                fftQ = fftQ(end-fftLength+1:end);
            end

            % FFT I
            sI = fftI - mean(fftI);
            YI = fft([sI; zeros(fftLengthZP - fftLength,1)]);
            P2I = abs(YI/fftLength);
            PI = P2I(1:fftLengthZP/2+1);
            PI(2:end-1) = 2*PI(2:end-1);
            set(hI_fft,'YData',PI);

            % FFT Q
            sQf = fftQ - mean(fftQ);
            YQ = fft([sQf; zeros(fftLengthZP - fftLength,1)]);
            P2Q = abs(YQ/fftLength);
            PQ = P2Q(1:fftLengthZP/2+1);
            PQ(2:end-1) = 2*PQ(2:end-1);
            set(hQ_fft,'YData',PQ);

            drawnow limitrate;

            plotUpdateCounter = plotUpdateCounter + 1;
            if mod(plotUpdateCounter,50) == 0
                % Debug: schreib FIFO-Status
                udlocal = s.UserData;
                fprintf('FIFO count: %d / %d | writePos=%d readPos=%d\n', ...
                    udlocal.count, FIFO_CAPACITY, udlocal.writePos, udlocal.readPos);
            end
        else
            % Wenn nichts zu tun: kurze Pause, damit GUI & callback laufen
            pause(0.001);
        end

        % Optional: Abbruchbedingung (Fenster geschlossen)
        if ~isvalid(player) || ~ishandle(hI_time)
            running = false;
        end
    end

catch ME
    disp('Fehler im Mainloop:');
    disp(ME.message);
    for k=1:length(ME.stack), fprintf('%s:%d\n', ME.stack(k).file, ME.stack(k).line); end
end

%% ---------------- Cleanup ----------------
try
    release(player);
    clear player;
    configureCallback(s, "off"); % Callback ausschalten
    flush(s);
    clear s;
catch
end

disp('Beendet.');

%% ---------------- Helper Functions ----------------
function serialCallback(src, ~, BLOCK_SIZE)
    % Callback wird aufgerufen, sobald genügend Bytes angekommen sind
    
    % Daten lesen mit BLOCK_SIZE*2 für I und Q aus einem Paket
    raw = read(src, BLOCK_SIZE*2, "int16");  
    if isempty(raw)
        return
    end

    % I/Q aufteilen
    dataI = raw(1:2:end);
    dataQ = raw(2:2:end);

    % I und Q in FIFO schreiben
    fifo_push(src, dataI, dataQ);
end

function fifo_push(sobj, dataI, dataQ)
    ud = sobj.UserData;

    n = numel(dataI);
    if n == 0, return; end

    % einfache "lock"
    tries = 0;
    while ud.lock && tries < 5
        pause(0.0005);
        ud = sobj.UserData;
        tries = tries + 1;
    end
    ud.lock = true;

    capacity = numel(ud.fifoI);

    % Platz prüfen, bei Bedarf älteste Samples verwerfen
    freeSlots = capacity - double(ud.count);
    if freeSlots < n
        drop = n - freeSlots;
        ud.readPos = uint32(mod(double(ud.readPos - 1 + drop), capacity) + 1);
        ud.count = uint32(max(0, double(ud.count) - drop));
    end

    wp = double(ud.writePos);
    if wp + n - 1 <= capacity
        ud.fifoI(wp:wp+n-1) = dataI;
        ud.fifoQ(wp:wp+n-1) = dataQ;
        wp = wp + n;
    else
        firstPart = capacity - wp + 1;
        ud.fifoI(wp:end) = dataI(1:firstPart);
        ud.fifoQ(wp:end) = dataQ(1:firstPart);
        secondPart = n - firstPart;
        ud.fifoI(1:secondPart) = dataI(firstPart+1:end);
        ud.fifoQ(1:secondPart) = dataQ(firstPart+1:end);
        wp = secondPart + 1;
    end

    ud.writePos = uint32(mod(wp-1, capacity) + 1);
    ud.count = uint32(double(ud.count) + n);

    ud.lock = false;
    sobj.UserData = ud;
end

function [dataI, dataQ] = fifo_pop(sobj, n)
    ud = sobj.UserData;
    capacity = numel(ud.fifoI);

    n = min(n, double(ud.count));
    if n == 0
        dataI = zeros(0,1,'int16');
        dataQ = zeros(0,1,'int16');
        return;
    end

    tries = 0;
    while ud.lock && tries < 5
        pause(0.0005);
        ud = sobj.UserData;
        tries = tries + 1;
    end
    ud.lock = true;

    rp = double(ud.readPos);
    if rp + n - 1 <= capacity
        dataI = ud.fifoI(rp:rp+n-1);
        dataQ = ud.fifoQ(rp:rp+n-1);
        rp = rp + n;
    else
        firstPart = capacity - rp + 1;
        dataI = [ud.fifoI(rp:end); ud.fifoI(1:n-firstPart)];
        dataQ = [ud.fifoQ(rp:end); ud.fifoQ(1:n-firstPart)];
        rp = n - firstPart + 1;
    end

    ud.readPos = uint32(mod(rp-1, capacity) + 1);
    ud.count = uint32(double(ud.count) - n);

    ud.lock = false;
    sobj.UserData = ud;
end
